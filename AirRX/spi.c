/*
 * spi.c
 *
 * Created: 12/2/2018 9:24:48 AM
 *  Author: martan
 */ 
#include <avr/io.h>
#include "spi.h"


/*
uint8_t initRxData[48] = {0x40, // address byte, start with reg 0, in burst mode
    0x2E, // IOCFG2  // High impedance (3-state)
    0x2E, // IOCFG1  // High impedance (3-state)
    0x0D, // IOCFG0  // Serial Data Output. Asynchronous serial mode
    0x07, // FIFOTHR
    0xD3, // SYNC1
    0x91, // SYNC0
    0xFF, // PKTLEN
    0x04, // PKTCTRL1 // Append payload with status bytes, no address check
    0x32, // PKTCTRL0 // Asynchronous serial mode, infinite packet length
    0x00, // ADDR
    0x4B, // CHANNR
    0x06, // FSCTRL1* (Reset value: 0x0F)
    0x00, // FSCTRL0
    0x22, // FREQ2
    0xB7, // FREQ1
    0x55, // FREQ0
    0x8A, // MDMCFG4* // Changed as a test in conjunction w/ MDMCFG3
    0x93, // MDMCFG3* // Changed as a test in conjunction w/ MDMCFG4
    0x00, // MDMCFG2*
    0x23, // MDMCFG1
    0x3B, // MDMCFG0*
    0x50, // DEVIATN*
    0x07, // MCSM2
    0x30, // MCSM1
    0x18, // MCSM0
    0x16, // FOCCFG
    0x6C, // BSCFG
    0x03, // AGCCTRL2
    0x40, // AGCCTRL1
    0x91, // AGCCTRL0
    0x87, // WOREVT1
    0x6B, // WOREVT0
    0xF8, // WORCTRL
    0x56, // FREND1    0101 0110
    0x10, // FREND0    0001 0000
    0xE9, // FSCAL3
    0x2A, // FSCAL2
    0x00, // FSCAL1
    0x1F, // FSCAL0
    0x40, // RCCTRL1
    0x00, // RCCTRL0
    0x59, // FSTEST*
    0x7F, // PTEST
    0x3F, // AGCTEST*
    0x81, // TEST2
    0x35, // TEST1
0x09};// TEST0

*/

// init[RT]xData settings.
//                         |    |    |    |    |    |    |    |    |    |    |    |    FSCTRL1 (Dep on fXOSC) IF Freq
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    FSCTRL0 (Dep on fXOSC) IF Freq
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    FREQ2 (Dep on desire Base Freq & fXOSC) Base Freq
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    FREQ1 (Dep on desired Base Freq & fXOSC) Base Freq
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    FREQ0 (Dep on desired Base Freq & fXOSC) Base Freq
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    MDMCFG4 (Dep on fXOSC) CHANBW_E[7:6], CHANBW_M[5:4], DRATE_E[3:0]
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    MDMCFG3 (Dep on fXOSC) DRATE_M[7:0]
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    MDMCFG2 DEM_DCFILT_OFF[7:7], MOD_FORMAT[6:4], MANCHESTER_EN[3:3], SYNC_MODE[2:0]
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    MDMCFG1 FEC_EN[7:7], NUM_PREAMBLE[6:4], NOT_USED[3:2], CHANSPC_E[1:0]
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    MDMCFG0 (Dep on fXOSC) CHANSPC_M[7:0]
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    DEVIATN (Dep on fXOSC) NOT_USED[7:7], DEVIATION_E[6:4], NOT_USED[3:3], DEVIATION_M[2:0]
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |
//                         |    |    |    |    |    |    |    |    |    |    |    |    |    |    *    *    *    *    *    |    |    *    *    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |
#define Rx_26MHz_NA        0x40,0x2E,0x2E,0x0D,0x07,0xD3,0x91,0xFF,0x04,0x32,0x00,0x4B,0x06,0x00,0x22,0xB7,0x55,0x8A,0x93,0x00,0x23,0x3B,0x50,0x07,0x30,0x18,0x16,0x6C,0x03,0x40,0x91,0x87,0x6B,0xF8,0x56,0x10,0xE9,0x2A,0x00,0x1F,0x40,0x00,0x59,0x7F,0x3F,0x81,0x35,0x09
#define Tx_26MHz_NA        0x40,0x2E,0x2E,0x0D,0x07,0xD3,0x91,0xFF,0x04,0x32,0x00,0x4B,0x06,0x00,0x22,0xB7,0x55,0x8C,0x22,0x00,0x23,0x3B,0x50,0x07,0x30,0x18,0x16,0x6C,0x03,0x40,0x91,0x87,0x6B,0xF8,0x56,0x10,0xE9,0x2A,0x00,0x1F,0x40,0x00,0x59,0x7F,0x3F,0x81,0x35,0x09
#define Rx_26MHz_EU        0x40,0x2E,0x2E,0x0D,0x07,0xD3,0x91,0xFF,0x04,0x32,0x00,0x4B,0x06,0x00,0x21,0x74,0xAD,0x8A,0x93,0x00,0x23,0x3B,0x50,0x07,0x30,0x18,0x16,0x6C,0x03,0x40,0x91,0x87,0x6B,0xF8,0x56,0x10,0xE9,0x2A,0x00,0x1F,0x40,0x00,0x59,0x7F,0x3F,0x81,0x35,0x09
#define Tx_26MHz_EU        0x40,0x2E,0x2E,0x0D,0x07,0xD3,0x91,0xFF,0x04,0x32,0x00,0x4B,0x06,0x00,0x21,0x74,0xAD,0x8C,0x22,0x00,0x23,0x3B,0x50,0x07,0x30,0x18,0x16,0x6C,0x03,0x40,0x91,0x87,0x6B,0xF8,0x56,0x10,0xE9,0x2A,0x00,0x1F,0x40,0x00,0x59,0x7F,0x3F,0x81,0x35,0x09

#define Rx_27MHz_NA        0x40,0x2E,0x2E,0x0D,0x07,0xD3,0x91,0xFF,0x04,0x32,0x00,0x4B,0x06,0x00,0x21,0x6E,0x2C,0x8A,0x93,0x00,0x23,0x2F,0x47,0x07,0x30,0x18,0x16,0x6C,0x03,0x40,0x91,0x87,0x6B,0xF8,0x56,0x10,0xE9,0x2A,0x00,0x1F,0x40,0x00,0x59,0x7F,0x3F,0x81,0x35,0x09
#define Tx_27MHz_NA        0x40,0x2E,0x2E,0x0D,0x07,0xD3,0x91,0xFF,0x04,0x32,0x00,0x4B,0x06,0x00,0x21,0x6E,0x2C,0x8C,0x22,0x00,0x23,0x2F,0x47,0x07,0x30,0x18,0x16,0x6C,0x03,0x40,0x91,0x87,0x6B,0xF8,0x56,0x10,0xE9,0x2A,0x00,0x1F,0x40,0x00,0x59,0x7F,0x3F,0x81,0x35,0x09
#define Rx_27MHz_EU        0x40,0x2E,0x2E,0x0D,0x07,0xD3,0x91,0xFF,0x04,0x32,0x00,0x4B,0x06,0x00,0x20,0x37,0x77,0x8A,0x93,0x00,0x23,0x2F,0x47,0x07,0x30,0x18,0x16,0x6C,0x03,0x40,0x91,0x87,0x6B,0xF8,0x56,0x10,0xE9,0x2A,0x00,0x1F,0x40,0x00,0x59,0x7F,0x3F,0x81,0x35,0x09
#define Tx_27MHz_EU        0x40,0x2E,0x2E,0x0D,0x07,0xD3,0x91,0xFF,0x04,0x32,0x00,0x4B,0x06,0x00,0x20,0x37,0x77,0x8C,0x22,0x00,0x23,0x2F,0x47,0x07,0x30,0x18,0x16,0x6C,0x03,0x40,0x91,0x87,0x6B,0xF8,0x56,0x10,0xE9,0x2A,0x00,0x1F,0x40,0x00,0x59,0x7F,0x3F,0x81,0x35,0x09


/***** These two are for AirRx, the Anaren Chipset via Darrell and the Elec Home Board via mail order ****/

#define Rx_Anaren_NA       0x40,0x2E,0x2E,0x0D,0x07,0xD3,0x91,0xFF,0x04,0x32,0x00,0x4B,0x06,0x00,0x21,0x6E,0x2C,0x8A,0x93,0x00,0x23,0x2F,0x47,0x07,0x30,0x18,0x16,0x6C,0x03,0x40,0x91,0x87,0x6B,0xF8,0x56,0x10,0xE9,0x2A,0x00,0x1F,0x40,0x00,0x59,0x7F,0x3F,0x81,0x35,0x09
#define Rx_Darrell        0x40,0x2E,0x2E,0x0D,0x07,0xD3,0x91,0xFF,0x04,0x32,0x00,0x4B,0x06,0x00,0x22,0xB7,0x55,0x8A,0x93,0x00,0x23,0x3B,0x50,0x07,0x30,0x18,0x16,0x6C,0x03,0x40,0x91,0x87,0x6B,0xF8,0x56,0x10,0xE9,0x2A,0x00,0x1F,0x40,0x00,0x59,0x7F,0x3F,0x81,0x35,0x09

//uint8_t initData[48] = {Rx_Darrell};          // Darrell
//uint8_t initData[48] = {Rx_Anaren_NA};      // Anaren
	
// Elec home offbrand	
uint8_t initData[48] = {0x40, 0x2E, 0x2E, 0x0D, 0x07, 0xD3, 0x91, 0xFF,
	0x04, 0x32, 0x00, 0x4B, 0x06, 0x00, 0x22, 0xB7,
	0x55, 0x8A, 0x93, 0x00, 0x23, 0x3B, 0x50, 0x07,
	0x30, 0x18, 0x16, 0x6C, 0x03, 0x40, 0x91, 0x87,
	0x6B, 0xF8, 0x56, 0x10, 0xE9, 0x2A, 0x00, 0x1F,
0x40, 0x00, 0x59, 0x7F, 0x3F, 0x81, 0x35, 0x09};	
	

// Channels designations are 0-16.  These are the corresponding values
// for the CC1101.
uint8_t channels[17] = {0x4B, 0x45, 0x33, 0x27, 0x1B, 0x15, 0x0F, 0x03, 0x5E,
                        0x58, 0x52, 0x3E, 0x39, 0x2C, 0x21, 0x09, 0x37};

// Transmitter power settings are designated 0-10.  These are the corresponding
// PATABLE entries to set these powers.

uint8_t powers[11] = {0x03, 0x15, 0x1C, 0x27, 0x66, 0x8E, 0x89, 0xCD, 0xC4,0xC1, 0xC0};

#define RX      0x34
#define TX      0x35
#define STOP    0x36
#define PATABLE 0x3E
#define CHAN    0x0A
#define SS      0x04
#define SNOP    0x3d

#define WRITE_BURST              0x40
#define READ_SINGLE              0x80
#define READ_BURST               0xC0


void initializeSPI()
{
    USICR = 0;
    USICR |=  (1<<USIWM0);                 // set three wire mode (SPI)
    USICR |=  (1<<USICS1) | (1<<USICLK);   // Software Clock Strobe, positive edge

    SPI_DDR_PORT |= (1<<USCK_DD_PIN);   // set the USCK pin as output
    SPI_DDR_PORT |= (1<<DO_DD_PIN);     // set the DO pin as output
    SPI_DDR_PORT &= ~(1<<DI_DD_PIN);    // set the DI pin as input
    SPI_DDR_PORT |= SPI_LATCH;          // set select to output
}

/* clock out a btyte to SPI */

uint8_t spi_transfer(uint8_t data) 
{
    USIDR = data;
    USISR = (1<<USIOIF);                // clear counter and counter overflow interrupt flag
    while ( !(USISR & (1<<USIOIF))) 
         USICR |= (1<<USITC);
    return USIDR;
}

#define RXPOWER 0x89
void startModem(uint8_t channel)
{
    uint8_t i;
  
    uint8_t channelCode = channels[channel];
    
    PORTA &= ~SPI_LATCH;
    spi_transfer(STOP);              // send stop command to modem
    PORTA |= SPI_LATCH;
    
    PORTA &= ~SPI_LATCH;
    for(i=0; i<48; i++)              // Intialize all the registers
      spi_transfer(initData[i]);
    PORTA |= SPI_LATCH;

    PORTA &= ~SPI_LATCH;
    spi_transfer(PATABLE);           // Power Command
    PORTA |= SPI_LATCH;

    PORTA &= ~SPI_LATCH;
    spi_transfer(RXPOWER);           // And hardcoded for RX
    PORTA |= SPI_LATCH;

    PORTA &= ~SPI_LATCH;
    spi_transfer(CHAN);              // Channel Command
    //PORTA |= SPI_LATCH;

    //PORTA &= ~SPI_LATCH;
    spi_transfer(channelCode);
    PORTA |= SPI_LATCH;
 
    PORTA &= ~SPI_LATCH;
    spi_transfer(RX);                // RX mode
    PORTA |= SPI_LATCH;
}


 